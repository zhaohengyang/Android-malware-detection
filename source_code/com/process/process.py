'''
@author: zhaohengyang
Copyright (c) 2015 zhaohengyang. All rights reserved.
'''

import os,re
from com.weka.weka_interface import *
from time import clock

class ClassNode(object):

    def getClassPath(self):
        return self.classPath
    
    def getClassName(self):
        return self.className
    
    def getClassFullName(self):
        return self.classFullName

    def getClassType(self):
        return self.classType
    
    def getInvokeMethodList(self):
        return self.invokeMethodList
    
    
    def __init__(self, path, name):
        self.classPath = path
        self.className = name


        self.classFullName = ""
        self.classType = "other"
        self.invokeMethodList = []
        self.initialize(path)
    
    def updateType(self, cType):
        # First type found which means classType is still in default value("other"):
        if cType == "other":
            return
        
        #print "update:" + self.className + " from:" + self.classType + " to: " + cType
        if self.classType == "other":
            self.classType = cType
        
        else:
            typeList = cType.split(",") #cType can be "activity,service"
            for typeItem in typeList:
                # Found type is not exist, add type to it
                if self.classType.find(typeItem) == -1:
                    self.classType = self.classType + "," + typeItem

    def checkFirstTwoLine(self, filePath):
        smaliFile = open(filePath,'r')
        firstLine = smaliFile.readline()
        
        firstLine = firstLine.split(" ")[-1]
        self.classFullName = firstLine[:-2]
        #print "classFullName:" + self.classFullName
        secondLine = smaliFile.readline()
        #print  self.className + ": " + secondLine
        
        if secondLine == ".super Landroid/app/Activity;\n":
            #print "update activity"
            self.updateType("activity")
        elif secondLine == ".super Landroid/app/Service;\n":
            self.updateType("service")
        elif secondLine == ".super Landroid/content/BroadcastReceiver;\n":
            self.updateType("receiver")
        elif secondLine == ".super Landroid/content/ContentProvider;\n":
            self.updateType("provider")
        smaliFile.close()
    
     
    # Extract essential APIs from smali files
    def initialize(self, filePath):
        # initialize class full name and class type
        self.checkFirstTwoLine(filePath)
        
        # initialize invokelist
        smaliFile = open(filePath,'r')       
        for line in smaliFile:
            #print line
                   
            if re.search(r'^ *invoke', line):
                #print "line:"+ line
                if line.find(";->") != -1 :
                    className,methodName = line.split(";->")
                else:
                    continue
                temp,className = className.split("}, ")
                #if className.find("$") != -1 :
                #    tempList = className.split("$")
                #    className = tempList[0]
                methodName,temp = methodName.split("(")
                methodName = methodName + "()"
                systemCall = className + '->' + methodName
                #print systemCall
                
                self.invokeMethodList.append(systemCall)
                   
        smaliFile.close()
    
    
    def serizalize(self, outputPath):
        outputFile = open(outputPath,'a')
        outputFile.write(self.classType + "\t\t" + self.className + "\n")
        
    
        
class Sample():

    
    def __init__(self, path):
        self.samplePath = path
        self.manifestPath = path + '/' + 'AndroidManifest.xml'
        self.ClassNodeList = []
        self.startPointNum = 0
        self.finishedClassInOneRound = [] # Each note can only been visit once in one round
        
        
        
    def listClassPath(self, dir):
        classPathList = []
        for root,dirs,files in os.walk(dir):
            for filespath in files:           
                fullPath = os.path.join(root,filespath)
                if re.search(r'.smali$', fullPath):
                    #print fullPath    
                    classPathList.append(fullPath) 
        return classPathList
    
    def getClassNodeIndex(self, classFullName):
        for index in range(0, len(self.ClassNodeList)):
            if self.ClassNodeList[index].getClassFullName() == classFullName:
                return index
        
    def initialize(self):
        classPathList = self.listClassPath(self.samplePath)
        # Load all smali file into class node,
        for classPath in classPathList:
            filePathNoExt = os.path.splitext(classPath)[0]
            className = os.path.basename(filePathNoExt)
            self.ClassNodeList.append(ClassNode(classPath, className))
        
        checkNum = 0
        # Put four types of class node to the top of the list
        for classNode in self.ClassNodeList:
            if classNode.getClassType() != "other":
                checkNum += 1
                self.ClassNodeList.insert(0, self.ClassNodeList.pop(self.ClassNodeList.index(classNode)))
        self.startPointNum = checkNum
        
    
    def update(self, currentNode, classFullNameList, type):  
        children = []
        currentNode.updateType(type)
        if currentNode.getClassFullName() not in self.finishedClassInOneRound:
            self.finishedClassInOneRound.append(currentNode.getClassFullName()) # Each note can only been visit once in one round
        
        #print "go down! current node:" + str(self.ClassNodeList.index(currentNode)) + "\t" + currentNode.getClassName()
        #print "current node:" + currentNode.getClassFullName()
        #print self.finishedClassInOneRound
        for invokeFullName in currentNode.getInvokeMethodList(): # check all possible invoke class
            invokeClassFullName = invokeFullName.split("->")[0]
            # if the invoke class can be found in the class node list
            # also, the class node havn't been visited, then, save for later visit
            if invokeClassFullName in classFullNameList:
                #print "invokeClassFullName: " + invokeClassFullName
                index = self.getClassNodeIndex(invokeClassFullName)
                #print "index: " + str(index)
                children.append(index)
        
            
        
        # Go visit all the node
        for index in children:
            if self.ClassNodeList[index].getClassFullName() not in self.finishedClassInOneRound:
                self.update(self.ClassNodeList[index], classFullNameList, type)
            #print children
            
        #print "go up!" + "current node:" + str(self.ClassNodeList.index(currentNode)) + "\t" + currentNode.getClassName()
        
    def mark(self):
        # initialize
        self.initialize()  
        
        # Create a name list from class node list
        classFullNameList = []
        for classNode in self.ClassNodeList:
            #print classNode.getClassType()
            classFullNameList.append(classNode.getClassFullName())
            
        # Update each class node, only search from each start points
        for index in range(0, self.startPointNum):
            self.update(self.ClassNodeList[index], classFullNameList, self.ClassNodeList[index].getClassType())
            self.finishedClassInOneRound = [] 
            #print "currentRound: " + str(index)

        # Update each sub-classes
        for index in range(0,len(self.ClassNodeList)):
            name = self.ClassNodeList[index].getClassName()
            if name.find("$") != -1:
                name = name.split("$")[0]
            
            for node in self.ClassNodeList:
                if node.getClassName() == name:
                    self.ClassNodeList[index].updateType(node.getClassType())
                    #print self.ClassNodeList[index].getClassName() + " " + self.ClassNodeList[index].getClassType()
    
    def outputPrecentageOfMark(self, outputPath):
        totalNum = len(self.ClassNodeList)
        uncovered = 0
        for classN in self.ClassNodeList: 
            if classN.getClassType() == "other":
                uncovered += 1
        if totalNum > 0:
            print "percentageOfMarK: " + str(float(totalNum - uncovered)/float(totalNum))
            outputFile = open(outputPath, "a")
            outputFile.write(str(float(totalNum - uncovered)/float(totalNum)) + "\n") 
        else:
            print "percentageOfMarK: 1"
            outputFile = open(outputPath, "a")
            outputFile.write("1\n")        
        
    def serizalize(self, outputPath):
        for classNode in self.ClassNodeList:
            #print classNode.getClassType()
            classNode.serizalize(outputPath)
         
    def proceesEachClass(self):
        #print "Sample::processEachClass"
        vectorDic = {}
        for classNode in self.ClassNodeList:
            typeList = classNode.getClassType().split(",") # parse class type
            for eachType in typeList:
                for invokeMethod in classNode.getInvokeMethodList():
                    if invokeMethod not in vectorDic.keys():
                        vectorDic[invokeMethod] = [0,0,0,0,0]
                    if eachType == "activity":
                        vectorDic[invokeMethod][0] = 1
                    elif eachType == "service":
                        vectorDic[invokeMethod][1] = 1
                    elif eachType == "provider":                
                        vectorDic[invokeMethod][2] = 1
                    elif eachType == "receiver":
                        vectorDic[invokeMethod][3] = 1
                    elif eachType == "other":
                        vectorDic[invokeMethod][4] = 1
                        
        return vectorDic
            
   
            
    # Extract features from the invoke list, update featurelist3 and featurelist4 in feature table        
    def extractFeatureFromAPIs(self, vectorDic, featureTable):
        #print "extractFeatureFromAPIs start:"
        for functionName in vectorDic.keys():     
            value = vectorDic[functionName][0] + 2 * vectorDic[functionName][1] + \
                4 * vectorDic[functionName][2] + 8 * vectorDic[functionName][3] 
            #print [functionName, vectorDic[functionName],value]
            if functionName in featureTable.featureList.keys():
                #print "found!!!!!"
                featureTable.featureList[functionName] = value
            
            

    

  
class processEngine():
        
    def createSchema(self, outputPath):
        # Wirte out schema part
        schema = FeatureTable()
        schema.createSchema(outputPath)
     
    # Process all the samples:
    # Get classNameList from the name of each smali file
    # Then, check each className in Manifest file to see where component it belongs to.
    def processSamples(self, samplePath, sampleType, outputPath):

            
            # Gather all decompiled sample root path into a list
            #print "processSamples: start" 
            samplePathList = []
            for directories in os.listdir(samplePath):
                if not re.search(r'^\..*', directories):
                    samplePathList.append(samplePath + "/" + directories)
                    
            preview = 0
            fininshed = 0
            for smaplePath in samplePathList:
                preview += 1
                print "preview: " + str(preview) + "\t\t" + smaplePath
        
            
            for samplePath in samplePathList:
                #print "samplePath:" + samplePath
                
                # Create five invoke lists
                sample = Sample(samplePath)
                sample.mark() 
                #sample.outputPrecentageOfMark(markPercentageRecordFilePath)
                vectorDic = sample.proceesEachClass()
                
                featureTable = FeatureTable()

                # Write out @data part
                # Extract features from invoke lists   
                sample.extractFeatureFromAPIs(vectorDic, featureTable)
                
                # Create matrix data, add it to arff file
                self.addDataToSchema(sampleType, featureTable, outputPath)
                
                fininshed += 1
                print "finished: " + str(fininshed) + "\t\t" + samplePath
    def writeRuntimeTitle(self):
        runTimeResultfile = open(runTimeProfermancePath, "w")        
        line = "size,time\n"
        runTimeResultfile.write(line)
            
    def processSamplesCheckingRuntime(self, samplePath, sampleType, outputPath):
            # include sample name, source code size and process time
            runTimeResultfile = open(runTimeProfermancePath, "a")        
            # Gather all decompiled sample root path into a list
            #print "processSamples: start" 
            samplePathList = []
            for directories in os.listdir(samplePath):
                if not re.search(r'^\..*', directories):
                    samplePathList.append(samplePath + "/" + directories)
                    
            preview = 0
            fininshed = 0
            for smaplePath in samplePathList:
                preview += 1
                print "preview: " + str(preview) + "\t\t" + smaplePath
        
            
            for samplePath in samplePathList:
                #print "samplePath:" + samplePath
                
                #print "samplePath:" + samplePath
                runTimeEvaluator = []
                #runTimeEvaluator.append(samplePath.split("/")[-1])
                codeSize = self.getFolderSize(samplePath + "/smali")
                start = clock()
                
                # Create five invoke lists
                sample = Sample(samplePath)
                sample.mark() 
                #sample.outputPrecentageOfMark(markPercentageRecordFilePath)
                vectorDic = sample.proceesEachClass()
                
                featureTable = FeatureTable()

                # Write out @data part
                # Extract features from invoke lists   
                sample.extractFeatureFromAPIs(vectorDic, featureTable)
                
                # Create matrix data, add it to arff file
                self.addDataToSchema(sampleType, featureTable, outputPath)
                
                fininshed += 1
                print "finished: " + str(fininshed) + "\t\t" + samplePath
                end = clock()
                    
                    
                if codeSize <= 20:
                    runTimeEvaluator.append(codeSize)
                    runTimeEvaluator.append(end - start)
                    line = "{0:.2f}".format(runTimeEvaluator[0]) + "," + "{0:.2f}".format(runTimeEvaluator[1]) + "\n"
                    print line
                    runTimeResultfile.write(line)
    
    def getFolderSize(self, folderPath):        
        folder_size = 0
        for (path, dirs, files) in os.walk(folderPath):
            for file in files:
                filename = os.path.join(path, file)
                folder_size += os.path.getsize(filename) 
        return folder_size/(1024*1024.0) 
    
                
    def addDataToSchema(self, sampleType, featureTable, outputPath):
        data = ""
        
        for key,value in featureTable.featureList.items():
            #print key + " : " + str(value)
            data += str(value) + ','  

        
        data += sampleType + "\n"
        
        outputfile = open(outputPath,'a') 
        outputfile.write(data)

      
'''        
sample = Sample("./malware/0a0c064d6d331df8c76ba9c4a7cbae7d7e19385f.apk")
sample.mark()    
sample.serizalize("./result/python_output.txt")
''' 


