'''
@author: zhaohengyang
Copyright (c) 2015 zhaohengyang. All rights reserved.
'''

from com.decompiler.decompiler import *
from com.process.process import *

class performanceTestForPaper(object):


    def __init__(self):
        self.processEn = processEngine()
        self.weka = WekaInterface()
        self.pTMgr = permissionMappingManager(databasePath)
        self.decompiler = Decompiler()


    def test1_1(self, reportFilePath, tableName, startSeed, numberOfRound):
        '''
        The general logic of test1_1() is the following:
        test1_1()
            showRankingByDissimilarityAndSampleCoverage()
                printFunctionInfoOrderedByIndex)()
                    # Get API with different evaluation score like dissimilarityAndSampleCoverage
                    getFunctionInfo()
                        # Get a feature's value list across all the training samples, each value in the list is distributed over (0, 15)
                        distributionOfAfeature()
                        # For each value, parse it to usage:[activity, service, provider, receiver]
                        # Save the summed usage across all the training samples
                        parseFunctionValue()
                        # Use the summed usage to calculate evaluation scores like sampleCoverage, dissimilarityAndSampleCoverage
                        calculateNormalizedDissimilarity()
                        # return a list of function and corresponding evaluation scores
                        return functionInfo

                    # Rank API by certain score
                    sort()
        '''

        originalFeatureNum = 0
        firstStepFeatureNum = 0
        secondStepFeautreNum = 0
        originalAccTraining = 0
        originalAccTesting = 0
        finalAccTraining = 0
        finalAccTesting = 0
    
        
       
        curveList = []
        for shuffleSeed in range(startSeed, startSeed + numberOfRound):
            self.weka.createTwoDatasets(wholeSetArffFilePath, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
            
            # Initialization
            trainingData = self.weka.load_Arff(trainingArffFilePath)
            testingData = self.weka.load_Arff(testingArffFilePath)
            numberOfInstance = self.weka.getNumOfInstance(trainingData)
            [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
            
            reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
            self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
            
            originalFeatureNum += trainingData.num_attributes() - 1
            firstStepFeatureNum += filteredTrainingData.num_attributes() - 1
            # Test1: renewed dissimilarity 
            # feature selection
        
            
            print "feature refinement"
            if tableName == TABLENAMES["frequencyDif"]:
                functionInfo = self.weka.showRankingByFrequencyDifference(filteredTrainingData)
            elif tableName == TABLENAMES["DissimilarityAndSampleCoverage"]:
                functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(filteredTrainingData)
                
            self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
            [bestAccuracy, trainDataByDis, dummy, resultList] = self.weka.attribueSelectionBasedOnRankingInDatabase(filteredTrainingData, 1, tableName, reportPath)
            # test final model
            testDataByDis = self.weka.filterUnusedFeatureBasedOnData(trainDataByDis, filteredTestingData)
            
            secondStepFeautreNum += trainDataByDis.num_attributes() - 1
            
            if len(curveList) == 0:
                for item in resultList:
                    curveList.append(float(item)) 
            else:
                for index in range(0, len(resultList)):
                    curveList[index] += float(resultList[index])
                    
            print "Training set"
            originalAccTraining += self.weka.evaluateResult(trainingData, 1)[0]
            finalAccTraining += self.weka.evaluateResult(trainDataByDis, 1)[0]
            
            print "Testing set"
            originalAccTesting += self.weka.evaluateResult(trainingData, 1, testingData)[0]
            finalAccTesting += self.weka.evaluateResult(trainDataByDis, 1, testDataByDis)[0]
            
            reportStructure = [originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum,
                            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting]
            title = "originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum, originalAccTraining, \
            originalAccTesting, finalAccTraining, finalAccTesting"
            print title
    
            reportStr = ""
            for item in reportStructure:
                reportStr += "{:.2f}".format(item) + ","
            print reportStr[0:-1] + "\n"
    
        
        reportStr = ""
        reportFile = open(reportFilePath, "w")
        
        reportStructure = [originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum,
                            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting]
         
        title = "originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum, originalAccTraining, \
            originalAccTesting, finalAccTraining, finalAccTesting"
        print title
        reportFile.write(title + "\n")
        
        for item in reportStructure:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")    
        
        print "curve:"
        reportFile.write("curve:")
        reportStr = ""
        for item in curveList:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")    
        
    # INfo gain on our features, final result in J48
    def test1_2(self, reportFilePath, startSeed, numberOfRound):
        
        originalFeatureNum = 0
        firstStepFeatureNum = 0
        secondStepFeautreNum = 0
        originalAccTraining = 0
        originalAccTesting = 0
        finalAccTraining = 0
        finalAccTesting = 0
    
        
       
        curveList = []
        for shuffleSeed in range(startSeed, startSeed + numberOfRound):
            self.weka.createTwoDatasets(wholeSetArffFilePath, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
            
            # Initialization
            trainingData = self.weka.load_Arff(trainingArffFilePath)
            testingData = self.weka.load_Arff(testingArffFilePath)
            numberOfInstance = self.weka.getNumOfInstance(trainingData)
            [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
            
            
            
            reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
            self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
            
            originalFeatureNum += trainingData.num_attributes() - 1
            firstStepFeatureNum += filteredTrainingData.num_attributes() - 1
            # Test1: renewed dissimilarity 
            # feature selection
        
            
            print "feature refinement"
            [bestAccuracy, trainDataByInfoGain, dummy, resultList] = self.weka.getTenScaledResultsRankedByInfo(filteredTrainingData, 1, reportPath)   
    
            # test final model
            testDataByInfoGain = self.weka.filterUnusedFeatureBasedOnData(trainDataByInfoGain, filteredTestingData)
            
            secondStepFeautreNum += trainDataByInfoGain.num_attributes() - 1
            
            if len(curveList) == 0:
                for item in resultList:
                    curveList.append(float(item)) 
            else:
                for index in range(0, len(resultList)):
                    curveList[index] += float(resultList[index])
                    
            print "Training set"
            originalAccTraining += self.weka.evaluateResult(trainingData, 1)[0]
            finalAccTraining += self.weka.evaluateResult(trainDataByInfoGain, 1)[0]
            
            print "Testing set"
            originalAccTesting += self.weka.evaluateResult(trainingData, 1, testingData)[0]
            finalAccTesting += self.weka.evaluateResult(trainDataByInfoGain, 1, testDataByInfoGain)[0]
            
            reportStructure = [originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum,
                            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting]
            title = "originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum, originalAccTraining, \
            originalAccTesting, finalAccTraining, finalAccTesting"
            print title
    
            reportStr = ""
            for item in reportStructure:
                reportStr += "{:.2f}".format(item) + ","
            print reportStr[0:-1] + "\n"
    
        
        reportStr = ""
        reportFile = open(reportFilePath, "w")
        
        reportStructure = [originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum,
                            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting]
         
        title = "originalFeatureNum, firstStepFeatureNum, secondStepFeautreNum, originalAccTraining, \
            originalAccTesting, finalAccTraining, finalAccTesting"
        print title
        reportFile.write(title + "\n")
        
        for item in reportStructure:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")    
        
        print "curve:"
        reportFile.write("curve:")
        reportStr = ""
        for item in curveList:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")    
        reportFile.close()
      
    # CAPI on top of Info gain, final result in j48
    def test2(self, reportFilePath,startSeed, numberOfRound):
        
    
        firstStepFeatureNum = 0
        secondStepFeautreNum = 0
        thirdStepFeautreNum = 0
        infoAccTraining = 0
        infoAccTesting = 0
        finalAccTraining = 0
        finalAccTesting = 0
    
        
       
        curveList = []
        for shuffleSeed in range(startSeed,startSeed + numberOfRound):
            self.weka.createTwoDatasets(wholeSetArffFilePath, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
            
            # Initialization
            trainingData = self.weka.load_Arff(trainingArffFilePath)
            testingData = self.weka.load_Arff(testingArffFilePath)
            numberOfInstance = self.weka.getNumOfInstance(trainingData)
            [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
            
            
            
            reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
            self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
            
            firstStepFeatureNum += filteredTrainingData.num_attributes() - 1
            # Test1: renewed dissimilarity 
            # feature selection
        
            
            print "Info feature refinement"
            [bestAccuracy, trainDataByInfoGain, dummy, resultList] = self.weka.getTenScaledResultsRankedByInfo(filteredTrainingData, 1, reportPath)   
    
            # test final model
            testDataByInfoGain = self.weka.filterUnusedFeatureBasedOnData(trainDataByInfoGain, filteredTestingData)
            
            secondStepFeautreNum += trainDataByInfoGain.num_attributes() - 1
            
            print "CAPI feature refinement"
            tableName = TABLENAMES["DissimilarityAndSampleCoverage"]
            functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(trainDataByInfoGain)
            self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
            [bestAccuracy, trainDataByDis, dummy, resultList] = self.weka.attribueSelectionBasedOnRankingInDatabase(trainDataByInfoGain, 1, tableName, reportPath)
            # test final model
            testDataByDis = self.weka.filterUnusedFeatureBasedOnData(trainDataByDis, testDataByInfoGain)
            
            thirdStepFeautreNum += trainDataByDis.num_attributes() - 1
    
    
            
                    
            print "Training set:"
            print "info gain"
            infoAccTraining += self.weka.evaluateResult(trainDataByInfoGain, 1)[0]
            print "CAPI"
            finalAccTraining += self.weka.evaluateResult(trainDataByDis, 1)[0]
            
            print "Testing set:"
            print "info gain"
            infoAccTesting += self.weka.evaluateResult(trainDataByInfoGain, 1, testDataByInfoGain)[0]
            print "CAPI"
            finalAccTesting += self.weka.evaluateResult(trainDataByDis, 1, testDataByDis)[0]
            
            reportStructure = [firstStepFeatureNum, secondStepFeautreNum, thirdStepFeautreNum,
                            infoAccTraining, infoAccTesting, finalAccTraining, finalAccTesting]
            title = "firstStepFeatureNum, secondStepFeautreNum, thirdStepFeautreNum, \
            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting"
            print title
    
            reportStr = ""
            for item in reportStructure:
                reportStr += "{:.2f}".format(item) + ","
            print reportStr[0:-1] + "\n"
    
        
        reportStr = ""
        reportFile = open(reportFilePath, "a")
        
        reportStructure = [firstStepFeatureNum, secondStepFeautreNum, thirdStepFeautreNum,
                            infoAccTraining, infoAccTesting, finalAccTraining, finalAccTesting]
        title = "firstStepFeatureNum, secondStepFeautreNum, thirdStepFeautreNum, \
            originalAccTraining, originalAccTesting, finalAccTraining, finalAccTesting"
        print title
        reportFile.write(title + "\n")
        
        for item in reportStructure:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")    
        
        print "curve:"
        reportFile.write("curve:")
        reportStr = ""
        for item in curveList:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print reportStr[0:-1] + "\n"
        reportFile.write(reportStr[0:-1] + "\n")  
            
    
    
    # final result on several algorithms 
    def test3_1(self, wholeSet, startSeed, numberOfRound, test3_acc_file, test3_AUR_file):
        


        accInFourAlgo = [0,0,0,0]
        AURInFourAlgo = [0,0,0,0]
        
        for algorithmIndex in range(0,len(self.weka.algorithmTable)): 
            for shuffleSeed in range(startSeed,startSeed + numberOfRound):
                self.weka.createTwoDatasets(wholeSet, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
                
                # Initialization
                trainingData = self.weka.load_Arff(trainingArffFilePath)
                testingData = self.weka.load_Arff(testingArffFilePath)
                numberOfInstance = self.weka.getNumOfInstance(trainingData)
                [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
                
                
                
                reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
                self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
                
                # Test1: renewed dissimilarity 
                # feature selection
            
                print "feature refinement"
                tableName = TABLENAMES["DissimilarityAndSampleCoverage"]
                functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(filteredTrainingData)
                self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
                [bestAccuracy, trainDataByDis, dummy, dumy] = self.weka.attribueSelectionBasedOnRankingInDatabase(filteredTrainingData, algorithmIndex, tableName, reportPath)
                # test final model
                testDataByDis = self.weka.filterUnusedFeatureBasedOnData(trainDataByDis, filteredTestingData)
    
                
                                    
                
                print "Testing set"
                
                
                [acc,AUR] =  self.weka.evaluateResult(trainDataByDis, algorithmIndex, testDataByDis)
                
                accInFourAlgo[algorithmIndex] += acc
                AURInFourAlgo[algorithmIndex] += AUR
    
    
        
        test3_acc_file = open(test3_acc, 'a')
        test3_AUR_file = open(test3_AUR, 'a')
        
        reportStr = ""
        
        for item in accInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "acc:" + reportStr[0:-1] + "\n"
        test3_acc_file.write(reportStr[0:-1] + "\n")    
        
        reportStr = ""
        
        for item in AURInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "AUR:" + reportStr[0:-1] + "\n"
        test3_AUR_file.write(reportStr[0:-1] + "\n") 
           
    def test3_temp(self, wholeSet, startSeed, numberOfRound):
        
        for algorithmIndex in range(0,len(self.weka.algorithmTable)): 
            for shuffleSeed in range(startSeed,startSeed + numberOfRound):
                self.weka.createTwoDatasets(wholeSet, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
                
                # Initialization
                trainingData = self.weka.load_Arff(trainingArffFilePath)
                testingData = self.weka.load_Arff(testingArffFilePath)
                numberOfInstance = self.weka.getNumOfInstance(trainingData)
                [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
                
                
                
                reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
                self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
                
                # Test1: renewed dissimilarity 
                # feature selection
            
                print "feature refinement"
                tableName = TABLENAMES["DissimilarityAndSampleCoverage"]
                functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(filteredTrainingData)
                self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
                [bestAccuracy, trainDataByDis, dummy, dumy] = self.weka.attribueSelectionBasedOnRankingInDatabase(filteredTrainingData, algorithmIndex, tableName, reportPath)
                # test final model
                testDataByDis = self.weka.filterUnusedFeatureBasedOnData(trainDataByDis, filteredTestingData)
    
                
                                    
                
                print "Testing set"
                
                
                [acc,AUR] =  self.weka.evaluateResult(trainDataByDis, algorithmIndex, testDataByDis)
                print("acc:",acc)
                print("AUR:",AUR)

    
    
        
        

        
    # final result on several algorithms of related approach with infoGain
    def test3_2(self, relatedWholeSet, startSeed, numberOfRound, test3_acc_file, test3_AUR_file):
        
        accInFourAlgo = [0,0,0,0]
        AURInFourAlgo = [0,0,0,0]
        
        for algorithmIndex in range(0,len(self.weka.algorithmTable)): 
            for shuffleSeed in range(startSeed,startSeed+numberOfRound):
                self.weka.createTwoDatasets(relatedWholeSet, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
                
                # Initialization
                trainingData = self.weka.load_Arff(trainingArffFilePath)
                testingData = self.weka.load_Arff(testingArffFilePath)

                [acc,AUR] =  self.weka.evaluateResult(trainingData, algorithmIndex, testingData)
                
                accInFourAlgo[algorithmIndex] += acc
                AURInFourAlgo[algorithmIndex] += AUR
                
                
        test3_acc_file = open(test3_acc, 'a')
        test3_AUR_file = open(test3_AUR, 'a')
        
        reportStr = ""
        
        for item in accInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "acc:" + reportStr[0:-1] + "\n"
        test3_acc_file.write(reportStr[0:-1] + "\n")    
        
        reportStr = ""
        
        for item in AURInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "AUR:" + reportStr[0:-1] + "\n"
        test3_AUR_file.write(reportStr[0:-1] + "\n") 

        '''
        for algorithmIndex in range(0,len(self.weka.algorithmTable)): 
            for shuffleSeed in range(startSeed,startSeed+numberOfRound):
                self.weka.createTwoDatasets(relatedWholeSet, 66.67, trainingArffFilePath, testingArffFilePath, shuffleSeed)
                
                # Initialization
                trainingData = self.weka.load_Arff(trainingArffFilePath)
                testingData = self.weka.load_Arff(testingArffFilePath)
                numberOfInstance = self.weka.getNumOfInstance(trainingData)
                [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
                
                
                
                reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
                self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
                
                # Test1: renewed dissimilarity 
                # feature selection
            
                print "feature refinement"
                [bestAccuracy, trainDataByInfoGain, dummy, dummy] = self.weka.getTenScaledResultsRankedByInfo(filteredTrainingData, algorithmIndex, reportPath)   
    
                # test final model
                testDataByInfoGain = self.weka.filterUnusedFeatureBasedOnData(trainDataByInfoGain, filteredTestingData)
    
                
                                    
                
                print "Testing set"
                
                
                [acc,AUR] =  self.weka.evaluateResult(trainDataByInfoGain, algorithmIndex, testDataByInfoGain)
                
                accInFourAlgo[algorithmIndex] += acc
                AURInFourAlgo[algorithmIndex] += AUR
        
    
        
        test3_acc_file = open(test3_acc, 'a')
        test3_AUR_file = open(test3_AUR, 'a')
        
        reportStr = ""
        
        for item in accInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "acc:" + reportStr[0:-1] + "\n"
        test3_acc_file.write(reportStr[0:-1] + "\n")    
        
        reportStr = ""
        
        for item in AURInFourAlgo:
            reportStr += "{:.2f}".format(item/numberOfRound) + ","
        print "AUR:" + reportStr[0:-1] + "\n"
        test3_AUR_file.write(reportStr[0:-1] + "\n") 
        '''