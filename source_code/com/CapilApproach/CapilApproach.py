
from com.weka.weka_interface import *
from com.decompiler.decompiler import *
from com.process.process import *

class CapilApproach(object):
    def __init__(self):
        self.processEn = processEngine()
        self.weka = WekaInterface()
        self.pTMgr = permissionMappingManager(databasePath)
        self.decompiler = Decompiler()    

    # step1
    def decompileSampleAPKs(self, sourcePath, destinationPath):       
        self.decompiler.decompilePath(sourcePath, destinationPath)
        
    # step2
    def extractFeaturesFromSampleSet(self):
        self.processEn.createSchema(additionalSampleArffilePath)
        self.processEn.processSamplesCheckingRuntime("/Users/zhaohengyang/Documents/malware detection/additional_malware/decompiled_samples", "malware", additionalSampleArffilePath) 
        #self.processEn.processSamplesCheckingRuntime("/Users/forensics/Documents/mike yang/mike_share_folder/mike new download/decompiled_samples", "benign", additionalSampleArffilePath) 
           
    # step3
    def featureRefinement(self, refinedArffPath):
        filteredData = self.weka.emlimitateUnusedFeature(wholeSetArffFilePath)
        tableName = TABLENAMES["DissimilarityAndSampleCoverage"]
        functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(filteredData)
        self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
        [dummy, filteredData, dummy] = self.weka.attribueSelectionBasedOnRankingInDatabase(filteredData, 1, tableName)
        self.weka.save_Arff(filteredData, refinedArffPath)
        
    # step4    
    def useClassifierForUnkownSample(self, arffPath, unknowSampleArffPath):
        treeStr = self.weka.getDecisionTree(arffPath)
        tree = self.weka.parseDecisionTree(treeStr)
        self.weka.useTreeForNewApps(tree, unknowSampleArffPath)

    '''    
    def generateTwoDatasets(self):
        self.weka.createTwoDatasets(wholeSetArffFilePath, 66.67, trainingArffFilePath, testingArffFilePath)
        
    def featureRefinementEvaluate(self):
        # Initialization
        trainingData = self.weka.load_Arff(trainingArffFilePath)
        testingData = self.weka.load_Arff(testingArffFilePath)
        numberOfInstance = self.weka.getNumOfInstance(trainingData)
        [filteredTrainingData,filteredTestingData] = self.weka.emlimitateUnusedFeature(trainingData, testingData)
        
        reportPath = "../workspace/results/DissimilarityAndSampleCoverage.txt"
        self.weka.writeTenScaledTitle(filteredTrainingData, reportPath)
        
        print "feature refinement"
        tableName = TABLENAMES["DissimilarityAndSampleCoverage"]
        functionInfo = self.weka.showRankingByDissimilarityAndSampleCoverage(filteredTrainingData)
        self.pTMgr.writeTopAPIIntoDatabase(functionInfo, tableName) 
        [bestAccuracy, trainDataByDis, dummy] = self.weka.attribueSelectionBasedOnRankingInDatabase(filteredTrainingData, 1, tableName, reportPath)
        # test final model
        testDataByDis = self.weka.filterUnusedFeatureBasedOnData(trainDataByDis, filteredTestingData)
        print "Training set"
        self.weka.evaluateResult(trainingData, 1)
        self.weka.evaluateResult(trainDataByDis, 1)
        
        print "Testing set"
        self.weka.evaluateResult(trainingData, 1, testingData)
        self.weka.evaluateResult(trainDataByDis, 1, testDataByDis)
    '''
        

    


        